# 邻接表存二叉树：可视化过程与 nxt[] 含义

本文以一棵样例二叉树为例，用 ASCII 图完整演示“邻接表（head/to/nxt）”是如何一步步构建的，并解释 `nxt[]` 数组的具体意义与用法。

---

## 图1：样例树形结构（1 为根）

```
1
├─ 2
│  ├─ 4
│  └─ 5
│     ├─ 8
│     └─ 9
└─ 3
   ├─ 6
   │  └─ 10
   └─ 7
```

对应输入（父→子）“按此顺序插入”：

1) 1 2
2) 1 3
3) 2 4
4) 2 5
5) 3 6
6) 3 7
7) 5 8
8) 5 9
9) 6 10

约定：边按加入顺序编号为 `e0..e8`（`idx` 从 0 开始）。

---

## 邻接表三件套与“头插法”

- `head[u]`：顶点 u 的“边链表”表头（存的是边的索引，若无边则为 -1）。
- `to[e]`：第 e 条边的终点（边从其起点 u 指向 `to[e]`）。
- `nxt[e]`：第 e 条边在“同一起点 u 的链表”里的下一条边的索引（若无则为 -1）。

插入一条边 u→v（头插，O(1)）：
```
to[idx]  = v
nxt[idx] = head[u]
head[u]  = idx
idx++
```
因为使用“头插法”，同一父节点的孩子在链表上的顺序为“逆插入顺序”。

---

## 初始状态

```
head[1..10] = -1
idx = 0
```

---

## 步骤 1：加入 1→2（e0）

```
to[e0]  = 2
nxt[e0] = -1
head[1] = e0
idx = 1
```
链视图：
```
head[1] -> e0
e0: to=2, nxt=-1

1 的子链：e0(to=2) -> null
```

---

## 步骤 2：加入 1→3（e1）

```
to[e1]  = 3
nxt[e1] = head[1] (=e0)
head[1] = e1
idx = 2
```
链视图：
```
head[1] -> e1
e1: to=3, nxt=e0
e0: to=2, nxt=-1

1 的子链：e1(to=3) -> e0(to=2) -> null    // 子序列：[3, 2]
```

---

## 步骤 3：加入 2→4（e2）

```
to[e2]  = 4
nxt[e2] = -1
head[2] = e2
idx = 3
```
链视图：
```
head[2] -> e2
e2: to=4, nxt=-1

2 的子链：e2(to=4) -> null
```

---

## 步骤 4：加入 2→5（e3）

```
to[e3]  = 5
nxt[e3] = head[2] (=e2)
head[2] = e3
idx = 4
```
链视图：
```
head[2] -> e3
e3: to=5, nxt=e2
e2: to=4, nxt=-1

2 的子链：e3(to=5) -> e2(to=4) -> null    // 子序列：[5, 4]
```

---

## 步骤 5：加入 3→6（e4）

```
to[e4]  = 6
nxt[e4] = -1
head[3] = e4
idx = 5
```
链视图：
```
head[3] -> e4
e4: to=6, nxt=-1

3 的子链：e4(to=6) -> null
```

---

## 步骤 6：加入 3→7（e5）

```
to[e5]  = 7
nxt[e5] = head[3] (=e4)
head[3] = e5
idx = 6
```
链视图：
```
head[3] -> e5
e5: to=7, nxt=e4
e4: to=6, nxt=-1

3 的子链：e5(to=7) -> e4(to=6) -> null    // 子序列：[7, 6]
```

---

## 步骤 7：加入 5→8（e6）

```
to[e6]  = 8
nxt[e6] = -1
head[5] = e6
idx = 7
```
链视图：
```
head[5] -> e6
e6: to=8, nxt=-1

5 的子链：e6(to=8) -> null
```

---

## 步骤 8：加入 5→9（e7）

```
to[e7]  = 9
nxt[e7] = head[5] (=e6)
head[5] = e7
idx = 8
```
链视图：
```
head[5] -> e7
e7: to=9, nxt=e6
e6: to=8, nxt=-1

5 的子链：e7(to=9) -> e6(to=8) -> null    // 子序列：[9, 8]
```

---

## 步骤 9：加入 6→10（e8）

```
to[e8]  = 10
nxt[e8] = -1
head[6] = e8
idx = 9
```
链视图：
```
head[6] -> e8
e8: to=10, nxt=-1

6 的子链：e8(to=10) -> null
```

---

## 最终邻接表总览

- head（只列有孩子的点）：
```
head[1] = e1
head[2] = e3
head[3] = e5
head[5] = e7
head[6] = e8
// 其他 head[u] = -1
```

- to / nxt（边表 e0..e8）：
```
e0: to=2,  nxt=-1
e1: to=3,  nxt=e0
e2: to=4,  nxt=-1
e3: to=5,  nxt=e2
e4: to=6,  nxt=-1
e5: to=7,  nxt=e4
e6: to=8,  nxt=-1
e7: to=9,  nxt=e6
e8: to=10, nxt=-1
```

- 每个父节点的子链（从 head[u] 沿 nxt 走到 null）：
```
1: e1(to=3) -> e0(to=2) -> null       // 子序列：[3, 2]
2: e3(to=5) -> e2(to=4) -> null       // 子序列：[5, 4]
3: e5(to=7) -> e4(to=6) -> null       // 子序列：[7, 6]
5: e7(to=9) -> e6(to=8) -> null       // 子序列：[9, 8]
6: e8(to=10) -> null                  // 子序列：[10]
4,7,8,9,10: 无子（head=-1）
```

---

## nxt[] 的具体含义（一句话与详解）

- 一句话：`nxt[e]` 是把“同一父节点 u 的多条边”连成单向链表的“下一条边”的索引（下标），配合 `head[u]` 形成邻接表。

- 详解：
  - 对于某个父节点 u，它的所有出边会构成一条链：从 `head[u]` 开始，沿 `nxt[e]` 不断前进，直到 `-1` 结束。
  - 采用“头插法”时，新边 `e_new` 的 `nxt[e_new] = head[u]`，然后 `head[u] = e_new`，等价于把新边插到链表表头。
  - 因此，链表中的边顺序是“逆插入顺序”。

- 遍历模板（C 代码）：
```c
for (int e = head[u]; e != -1; e = nxt[e]) {
    int v = to[e];
    // 处理 u -> v
}
```

- 常见易混：
  - `nxt[e]` 不是“下一节点”，而是“同一起点的下一条边”的索引；它把“边”连起来。
  - 若 `head[u] = -1` 表示 u 没有出边；若 `nxt[e] = -1` 表示链尾。

---

## 可选：打印邻接表的小工具

用于把“每个 u 的子序列”打印出来（便于和上面的 ASCII 图对照）：

```c
void print_adj(int n) {
    for (int u = 1; u <= n; ++u) {
        printf("%d:", u);
        for (int e = head[u]; e != -1; e = nxt[e]) {
            printf(" %d", to[e]);
        }
        printf("\n");
    }
}
```

示例输出（对应本例）：
```
1: 3 2
2: 5 4
3: 7 6
4:
5: 9 8
6: 10
7:
8:
9:
10:
```

---

## 小结

- 邻接表通过 `head[u] + (to[e], nxt[e])` 把“以 u 为起点”的所有边组织成链表，插入 O(1)、遍历 O(度数)。
- 对于树（父→子）场景，这种结构简洁高效，配合 `parent[v]` 可以轻松实现 BFS、层宽/深度统计与 LCA 等操作。
